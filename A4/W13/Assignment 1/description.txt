For this assignment, you are going to refactor/change the existing car parking program code from weeks 9, 10 and 11 for the last time. The current application is still not prepared for a bigger use. It uses multiple files, and even different kinds of files to keep the program's state. By refactoring the application to use sql we want achieve the following advantages

Faster searching in larger datasets
More consistent by only reading from one source
using a query can make the code simpler
Simpler for maintenance, only one database needs to be backuped.
Extra:

Instead of reading/writing a log file and storing the car parking machine state in a JSON file, you will use a database to replace this functionality completely. \ The database will contain information about checked-in and checked-out cars for all parking machines.
The database system used for this assignment will be an SQLITE (version 3.x) database.

Info:

Before starting, check if sqlite3 has already been installed on your system.
If not, information on how to install sqlite3 can be found on the SQLITE website: https://www.sqlite.org/
The import sqlite3 line will load the installed python sqlite3 module for use in your program.

Database:

To keep track of this information you are given a database structure with a single table.
This table has the following columns:

id
car_parking_machine
license_plate
check_in
check_out
parking_fee
You can use the following code in your __init__ of CarParkingMachine class to connect with the database and create it if it does not exist:

self.db_conn = sqlite3.connect(os.path.join(sys.path[0], 'carparkingmachine.db'))
self.db_conn.execute(
    '''CREATE TABLE IF NOT EXISTS parkings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        car_parking_machine TEXT NOT NULL,
        license_plate TEXT NOT NULL,
        check_in TEXT NOT NULL,
        check_out TEXT DEFAULT NULL,
        parking_fee NUMERIC DEFAULT 0
    );'''
)
Every row inserted in this PARKINGS table will represent a checked-in car at a specific car parking machine.
When a car checks-out, the existing row has to be updated with the check-out date and the calculated parking fee.
This way the table parkings will function as a log history of all parked cars.
It will also provide insight if a specific license plate is already checked-in at a specific car parking machine (to prevent duplicate check-ins).
The id (also called a primary key) of a row in the PARKINGS table will be automatically generated by the database using the built-in AUTOINCREMENT functionality (https://www.sqlite.org/autoinc.html).
So no id needs to be provided while inserting a row into the PARKINGS table.

Class CarParkingMachine:
Add the following functionality to your existing car parking machine

Methods:

def find_by_id(self, id) -> ParkedCar:
This method will search for a parked_car in the database based on the row ID an return a ParkedCar object with the data
def find_last_checkin(self, license_plate) -> int:
This method will search for the last row for a given license_plate that has NOT checked-out yet (return row ID if found)
def insert(self, parked_car: ParkedCar) -> ParkedCar:
This method will insert details of a created ParkedCar object and put the new row ID (from database) on the object, return the object with this new row ID
def update(self, parked_car: ParkedCar) -> None:
This method will update details of a ParkedCar object inside the database (update based on ParkedCar.id <- Datbase Row ID)
Changes:

The following functionality in your existing car parking machine program will be changed:

Removed the usage of a log file when checking-in and checking-out cars.
Adjust the ParkedCar class so it can store: id: int, license_plate: str, check_in: datetime, check_out: datetime, parking_fee: float
car parking init: restore the state of parked cars for a car parking machine by retrieving rows from the PARKINGS table
car parking check-in: insert a row into the PARKINGS to table instead of writing to the JSON state file.
car parking check-out: update the row in the database with check_out time and parking_fee information.
Adjust CarParkingReporter:
Adjust the carparkingreporter in such a way that it uses the database for the reports

Add the following menu item to carparkingreport:
[C] Report all complete parkings over all parking machines for a specific car

Input: license_plate
Output: csv file example (semicolon separated):

car_parking_machine;check_in;check_out;parking_fee
cpm_north;09-21-2022 16:20:04;09-21-2022 17:20:30;5.00
cpm_south;09-22-2022 14:11:03;09-23-2022 19:00:10;15.00